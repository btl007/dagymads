-- 1. 통합 감사 로그 테이블 생성 (audit_logs)
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    actor_id TEXT, -- 변경을 수행한 사용자 ID (Clerk ID 또는 System)
    target_table TEXT NOT NULL, -- 변경된 테이블명 (예: projects, user_profiles)
    target_id TEXT NOT NULL, -- 변경된 레코드의 PK (TEXT로 변환하여 저장)
    action_type TEXT NOT NULL, -- INSERT, UPDATE, DELETE, RESET_PASSWORD 등
    changes JSONB, -- 변경된 컬럼과 값 { "status": { "old": "A", "new": "B" } }
    metadata JSONB -- 기타 추가 정보 (요청 경로, IP 등 - 필요시)
);

-- RLS 설정: 관리자만 로그를 볼 수 있음 (일단은 모든 인증된 사용자에게 읽기 권한 부여하거나, Admin 로직에 따라 제한)
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Admins can view audit logs"
    ON public.audit_logs
    FOR SELECT
    USING (
        (auth.jwt() ->> 'public_metadata')::jsonb ->> 'is_admin' = 'true' 
        OR 
        (auth.jwt() ->> 'public_metadata')::jsonb ->> 'is_admin' = 'true'
    );

-- Edge Function 등에서 Insert 할 수 있도록
CREATE POLICY "System can insert audit logs"
    ON public.audit_logs
    FOR INSERT
    WITH CHECK (true); -- 실제로는 Service Role Key를 사용하므로 이 정책은 Client Insert용


-- 2. 범용 로깅 트리거 함수 (log_audit_event)
CREATE OR REPLACE FUNCTION public.log_audit_event()
RETURNS TRIGGER AS $$
DECLARE
    v_old_data JSONB;
    v_new_data JSONB;
    v_changes JSONB := '{}'::JSONB;
    v_target_id TEXT;
    v_actor_id TEXT;
    v_key TEXT;
    v_val_old JSONB;
    v_val_new JSONB;
BEGIN
    -- Actor ID 추출 (Supabase Auth Context에서)
    -- Clerk를 쓰므로 auth.jwt() -> 'sub' 또는 'user_id' 확인
    v_actor_id := auth.jwt() ->> 'sub';
    
    IF v_actor_id IS NULL THEN
        v_actor_id := 'system'; -- Edge Function이나 Console에서 실행된 경우
    END IF;

    -- Target ID 추출 (PK가 id라고 가정, 다르면 수정 필요하지만 보통 id 사용)
    IF (TG_OP = 'DELETE') THEN
        v_target_id := OLD.id::TEXT;
    ELSE
        v_target_id := NEW.id::TEXT;
    END IF;

    -- 변경 내용 추출 logic
    IF (TG_OP = 'INSERT') THEN
        v_changes := to_jsonb(NEW);
    ELSIF (TG_OP = 'UPDATE') THEN
        v_old_data := to_jsonb(OLD);
        v_new_data := to_jsonb(NEW);
        
        -- 변경된 컬럼만 찾아서 v_changes에 기록
        FOR v_key IN SELECT jsonb_object_keys(v_new_data)
        LOOP
            v_val_old := v_old_data -> v_key;
            v_val_new := v_new_data -> v_key;
            
            -- 값이 다를 경우에만 기록 (IS DISTINCT FROM 사용)
            IF (v_val_old IS DISTINCT FROM v_val_new) THEN
                -- updated_at 같은 자동 갱신 컬럼은 제외하고 싶다면 여기서 조건 추가
                IF v_key != 'updated_at' THEN
                    v_changes := jsonb_set(v_changes, ARRAY[v_key], jsonb_build_object('old', v_val_old, 'new', v_val_new));
                END IF;
            END IF;
        END LOOP;
        
        -- 변경된 내용이 없으면 로그 남기지 않음 (updated_at만 바뀌었을 수도 있으므로)
        IF v_changes = '{}'::JSONB THEN
            RETURN NEW;
        END IF;

    ELSIF (TG_OP = 'DELETE') THEN
        v_changes := to_jsonb(OLD);
    END IF;

    -- 로그 테이블에 저장
    INSERT INTO public.audit_logs (
        actor_id,
        target_table,
        target_id,
        action_type,
        changes
    ) VALUES (
        v_actor_id,
        TG_TABLE_NAME,
        v_target_id,
        TG_OP,
        v_changes
    );

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 3. 트리거 부착 (기존 테이블 대상)

-- Projects 테이블
DROP TRIGGER IF EXISTS trg_audit_projects ON public.projects;
CREATE TRIGGER trg_audit_projects
AFTER INSERT OR UPDATE OR DELETE ON public.projects
FOR EACH ROW EXECUTE FUNCTION public.log_audit_event();

-- User Profiles 테이블
-- 주의: user_profiles의 PK는 user_id일 수 있음. 트리거 함수는 .id를 찾으므로 확인 필요.
-- user_profiles 테이블 구조를 보면 PK가 user_id (text)임.
-- 따라서 트리거 함수를 조금 수정해야 함 (PK 컬럼명 감지).
-- 하지만 복잡도를 줄이기 위해, 아래에서 user_profiles 전용 트리거 함수를 만들거나
-- 위 함수에서 예외처리를 하는 것이 좋음.
-- 일단 위 함수는 .id를 가정하므로, user_profiles용으로 pk가 user_id인 경우를 처리하도록 함수 수정 필요.

-- 함수 수정 (PK 감지 로직 강화)
CREATE OR REPLACE FUNCTION public.log_audit_event()
RETURNS TRIGGER AS $$
DECLARE
    v_old_data JSONB;
    v_new_data JSONB;
    v_changes JSONB := '{}'::JSONB;
    v_target_id TEXT;
    v_actor_id TEXT;
    v_key TEXT;
    v_val_old JSONB;
    v_val_new JSONB;
BEGIN
    v_actor_id := auth.jwt() ->> 'sub';
    IF v_actor_id IS NULL THEN v_actor_id := 'system'; END IF;

    -- Target ID 추출 (PK 자동 감지가 어려우므로 관례적으로 id 또는 user_id 확인)
    -- TG_TABLE_NAME에 따라 분기하거나, JSONB 변환 후 키 존재 여부 확인
    IF (TG_OP = 'DELETE') THEN
        v_old_data := to_jsonb(OLD);
        IF v_old_data ? 'id' THEN
            v_target_id := (v_old_data ->> 'id');
        ELSIF v_old_data ? 'user_id' THEN
            v_target_id := (v_old_data ->> 'user_id');
        ELSE
            v_target_id := 'unknown';
        END IF;
    ELSE
        v_new_data := to_jsonb(NEW);
        IF v_new_data ? 'id' THEN
            v_target_id := (v_new_data ->> 'id');
        ELSIF v_new_data ? 'user_id' THEN
            v_target_id := (v_new_data ->> 'user_id');
        ELSE
            v_target_id := 'unknown';
        END IF;
    END IF;

    IF (TG_OP = 'INSERT') THEN
        v_changes := to_jsonb(NEW);
    ELSIF (TG_OP = 'UPDATE') THEN
        v_old_data := to_jsonb(OLD);
        v_new_data := to_jsonb(NEW);
        
        FOR v_key IN SELECT jsonb_object_keys(v_new_data)
        LOOP
            v_val_old := v_old_data -> v_key;
            v_val_new := v_new_data -> v_key;
            
            IF (v_val_old IS DISTINCT FROM v_val_new) THEN
                IF v_key != 'updated_at' THEN
                    v_changes := jsonb_set(v_changes, ARRAY[v_key], jsonb_build_object('old', v_val_old, 'new', v_val_new));
                END IF;
            END IF;
        END LOOP;
        
        IF v_changes = '{}'::JSONB THEN RETURN NEW; END IF;

    ELSIF (TG_OP = 'DELETE') THEN
        v_changes := to_jsonb(OLD);
    END IF;

    INSERT INTO public.audit_logs (actor_id, target_table, target_id, action_type, changes)
    VALUES (v_actor_id, TG_TABLE_NAME, v_target_id, TG_OP, v_changes);

    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- User Profiles 트리거 부착 (이제 안전함)
DROP TRIGGER IF EXISTS trg_audit_user_profiles ON public.user_profiles;
CREATE TRIGGER trg_audit_user_profiles
AFTER INSERT OR UPDATE OR DELETE ON public.user_profiles
FOR EACH ROW EXECUTE FUNCTION public.log_audit_event();

-- Time Slots 트리거 부착
DROP TRIGGER IF EXISTS trg_audit_time_slots ON public.time_slots;
CREATE TRIGGER trg_audit_time_slots
AFTER INSERT OR UPDATE OR DELETE ON public.time_slots
FOR EACH ROW EXECUTE FUNCTION public.log_audit_event();

-- Scripts 트리거 부착 (미리 해둠)
DROP TRIGGER IF EXISTS trg_audit_scripts ON public.scripts;
CREATE TRIGGER trg_audit_scripts
AFTER INSERT OR UPDATE OR DELETE ON public.scripts
FOR EACH ROW EXECUTE FUNCTION public.log_audit_event();
